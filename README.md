# Проектная работа 10

#тест
## Mesto

### Блоки

* **header** - здесь содержится только логотип и нижнее подчеркивание блока
* **main** - секция разметки основного контента
    * **profile** - секция в которой:
    - можно изменить с отправкой на сервер:
        - аватар профиля
        - название профиля
        - описание профиля
    - создать новую карточку:
        - добавив заголовок карточке
        - добавив ссылку на картинку
    * **grid** - секция с карточками, в них содержиться:
        - фото
        - описание
        - возможность поставить лайк
        - возможность открытия карточки с описанием
* **footer** - копирайт

* **popups** (диалоговые окна):
    - popup при клике на аватар - содержит поле ввода ссылки на смену аватара
    - popup при клике на редактирование профиля - содержит поля ввода заголовка и описания профиля
    - popup при клике на кнопку добавления - содержит поля ввода заголовка и ссылки на картинку
    - popup при клике на карточку - содержит картинку в полном масштабе и описание с альтернативным текстом

**Инфо**

Это небольшой проект-портфолио, созданный под разные экраны устройств, с точками перелома: 677px, 882px, 1200px.

* [Ссылки на макеты в Figma]
    * 4-й проект: ( https://www.figma.com/file/StZjf8HnoeLdiXS7dYrLAh/JavaScript.-Sprint-4 )
    * 5-й проект: ( https://www.figma.com/file/nlYpT4VhFiwimn2YlncrcF/JavaScript.-Sprint-5?node-id=90%3A311 )
    * 6-й проект: ( https://www.figma.com/file/XNaGNEZD5NEjeyJzAT4gMb/JavaScript.-Sprint-6 )
    * 7..9-й проект: (https://www.figma.com/file/LD0gRfv5QlfDNrpOb2wus3/Russia?node-id=131%3A541)

**GitHub Pages**

* [Ссылка на проект](https://stanislav-vasilevich.github.io/mesto/)

## Технологии, новые теги и языки

* в этой 9-й проектной работе я реализовал подключение к серверу и получения и отправки информации на него следующими методами:
    - ```GET```
    - ```POST```
    - ```PUT```
    - ```PUTCH```
    - ```DELETE```

Теперь все данные приходят динамически с сервера.

Также в проекте установлен ```node.j``` и все необходимые пакеты ```NP```, ```WebPac``` и плагины.

* использовал и технологии ***Flex*** и ***Grid Layout*** для закрепления материала в прошлых (4, 5, 6) практических работах.

* также в работе использовался язык программирования ```javascript```, а именно:
    * функции
    * объекты
    * события (submit, click, keydown)
    * валидация и др.

* в 7-й работе я реализовал рендер карточек в секцию ***grid*** и ***валидацию форм*** с помощью ***классов javascript***, также создал под классы отдельные файлы и настроил ***экспорт модулей*** в основной файл ```index.js```

    * [картинки подгружаются из файла Card.js]
    * Flex
    * Grid Layout
    * теги <form>
    * язык javascript в отдельном файле js/index.js для реализации диалоговых окон в секциях: profile и grid
    * язык javascript в отдельном файле js/FormValidator.js для реализации валидации форм
    * язык javascript в отдельном файле js/Card.js для реализации карточек в секцию grid

### Задание
<details>
<summary>Подробнее ...</summary>

# Проектная работа 10

### 1. Создайте новый проект на Create React App

В этой проектной работе вы начнёте портировать проект Mesto на «Реакт».

После настройки и запуска нового проекта вы увидите стандартную заставку:

![](https://pictures.s3.yandex.net/resources/Untitled_1593896697.png)

### 2. Ведите работу в новом репозитории

При создании нового проекта Create React App инициализирует локальный git-репозиторий. Кроме этого, как только вы перешли в урок проектной работы, удалённый репозиторий ```mesto-react``` скопировался в ваш аккаунт на «Гитхабе». Локальный и удалённый репозитории нужно связать.

Для этого скопируйте адрес удалённого репозитория:

![](https://pictures.s3.yandex.net/resources/github_mm_08_1603114903.jpg)

И свяжите локальный репозиторий с удалённым командой git remote add. Для этого, находясь в папке проекта, введите:

```javascript
git remote add origin адрес_репозитория 
```

```git push -u -f origin main ```

Флаг `````-u````` говорит о том, что локальная ветка ```main``` должна отслеживать удалённую. Такой флаг обычно используют при первом пуше, когда локальная и удалённая ветки ещё не связаны.

Флаг `````-f````` означает, что все удалённые коммиты указанной ветки необходимо переписать локальными. Этот флаг нужно использовать с осторожностью. Мы прибегаем к нему только для инициализации репозитория, а в дальнейшем использовать не будем.

### 3. Портируйте разметку
### Скопируйте HTML и конвертируйте его в JSX

В старом проекте был корневой элемент `````.page__content`````. Замените им содержимое компонента ```App```. Не забывайте, что JSX и HTML — не совсем одно и то же.

Если вы всё сделали правильно, вы должны увидеть промежуточный результат:

![](https://pictures.s3.yandex.net/resources/Untitled_1_1593896726.png)

Здорово, но могло бы быть и покрасивее. Кажется, нужно перенести стили.

### Портируйте стили

Стили компонента ```App.css``` больше не понадобятся — этот файл можно удалить.

Скопируйте папки ```blocks```, ```images``` и ```vendor``` из старого проекта. В новом проекте содержимое файла ```index.css``` замените на содержимое из ```pages/index.css```:

![](https://pictures.s3.yandex.net/resources/Untitled_1593896766.png)

Уже что-то, но не хватает логотипа. Импортируйте его правильным образом и подставьте полученный путь в JSX:

![](https://pictures.s3.yandex.net/resources/Untitled11_1593896800.png)

### 4. Вынесите первые компоненты

Пора начать наводить порядок в коде. Создайте папку ```src/components``` и перенесите в неё главный компонент приложения ```App.js```.

Создайте новый файл ```Header.js``` и вынесите в него элемент ```<header>``` в виде отдельного компонента. Импортируйте и используйте этот компонент внутри ```App```.

Аналогичным образом вынесите компоненты ```Main``` и ```Footer```.

Отлично: мы немного «разгрузили» основной компонент ```App```, хотя в нём всё ещё довольно много кода.

### 5. Настройте работу попапов

### Добавьте императивные обработчики

Чтобы добавить первую интерактивность, а заодно проверить, правильно ли вы портировали разметку попапов, внутри компонента ```Main``` добавьте следующие обработчики:

- ```handleEditAvatarClick```
- ```handleEditProfileClick```
- ```handleAddPlaceClick```

Здесь мы немного схитрим: внутри этих обработчиков временно используйте привычный императивный подход (с ```querySelector``` и ```classList.add```), чтобы задавать CSS-класс ```popup_is-opened``` элементу нужного попапа.

Теперь присвойте эти обработчики нужным элементам в JSX и убедитесь, что все три попапа открываются:

![](https://pictures.s3.yandex.net/resources/Untitled_1593896824.png)

Вскоре вы сможете перейти к декларативному подходу, но сперва нужно всё подготовить.

### Вынесите общий компонент попапов

Создайте компонент ```PopupWithForm``` и используйте его, чтобы вынести общий код следующих попапов:

- «Редактировать профиль»
- «Новое место»
- «Обновить аватар»
- «Вы уверены?»

В этих попапах много общей разметки: элементы внешнего и внутреннего контейнера, сама форма, заголовок и две кнопки. Вся общая разметка должна оказаться в новом компоненте. Извне должны будут передаваться только текст заголовка и идентификатор формы (в виде строк). Для этого добавьте соответствующие пропсы ```title``` и ```name``` и подставляйте их значения в JSX.

**Замечание 1.** Чтобы правильно подставить ```name``` в CSS-класс контейнера используйте следующую конструкцию:

```javascript
className={`popup popup_type_${props.name}`} 
```

**Замечание 2.** Значение пропса ```name``` будет использоваться не только в имени CSS-класса контейнера, но и для атрибута ```name``` тега ```form```.

Кроме заголовка и идентификатора в компонент ```PopupWithForm``` будет передаваться вложенное содержимое в виде JSX-разметки, отличающейся для всех четырёх попапов. Внутри самого компонента оно будет доступно через специальный пропс ```children```, который также должен быть подставлен в нужном месте в JSX.

### Вынесите компонент ```ImagePopup```

Здесь всё просто, этот компонент пока не имеет пропсов и вложенного содержимого.

### Декларативный подход

Начинается самое интересное. Для начала перенесите добавленные обработчики событий из компонента ```Main``` в компонент ```App```. При этом, чтобы они продолжали вызываться из компонента ```Main```, передавайте их в последний с помощью новых пропсов ```onEditProfile```, ```onAddPlace``` и ```onEditAvatar```.

Чтобы правильно реализовать декларативный подход, в компоненте ```App``` также должны появиться следующие переменные состояния, отвечающие за видимость трёх попапов:

- isEditProfilePopupOpen
- isAddPlacePopupOpen
- isEditAvatarPopupOpen

Теперь вы можете заменить императивный код в обработчиках событий на код, который будет изменять значения соответствующих переменных состояния, задавая в них значение ```true```.

Последнее, что нужно сделать, — добавить в компонент ```PopupWithForm``` пропc ```isOpen```, на основе которого в JSX будет задаваться CSS-класс, отвечающий за видимость попапа.

Наконец, в коде ```App``` значение ```isOpen``` каждого из трёх попапов должно задаваться с помощью соответствующей переменной состояния.

Если вы всё сделали правильно, попапы снова должны открываться, но теперь они управляются стейт-переменными — самый настоящий декларативный подход!

### Закрытие попапов

По аналогии со всеми предыдущими действиями реализуйте закрытие попапов. Вам поможет новый пропс ```onClose``` компонента ```PopupWithForm``` и его обработчик, который должен находиться внутри ```App``` и должен называться ```closeAllPopups```.

### 6. Подключите API

### Портируйте модуль API

Скопируйте файлы ```api.js``` и ```utils.js``` из старого проекта и положите их рядом в папке ```src/utils```.

Прямо внутри ```api.js``` создайте экземпляр класса ```Api``` с нужными параметрами (включая ваш токен) и экспортируйте этот экземпляр вместо самого класса.

### Используйте стейт для данных из API

В компоненте ```Main``` добавьте переменные состояния ```userName```, ```userDescription``` и ```userAvatar```. Используйте их в JSX.

Импортируйте модуль ```api``` и добавьте эффект, вызываемый при монтировании компонента, который будет совершать запрос в API за пользовательскими данными. После получения ответа задавайте полученные данные в соответствующие переменные состояния.

```Замечание.``` Чтобы подставить URL аватара в контейнер используйте такой код:

```javascript
style={{ backgroundImage: `url(${userAvatar})` }} 
```

Ура! Наконец-то должны появиться ваши сохранённые данные:

![](https://pictures.s3.yandex.net/resources/11Untitled_1593896872.png)

Ещё немного, и вы сможете увидеть карточки добавленных мест.

### 7. Настройте карточки мест

### Добавьте запрос к API

Добавьте ещё одну переменную стейта ```cards``` с пустым массивом в качестве значения по умолчанию. Добавьте второй запрос к API за соответствующими данными.

Из старого проекта скопируйте разметку карточки, находящуюся внутри тега ```template```, и используйте её внутри JSX-итерации по массиву ```cards```. Используйте подстановку данных элемента массива в JSX, чтобы вывести название карточки, количество лайков и указать URL изображения (как и прежде с помощью атрибута ```style```).

Немного подождите, пока загрузятся данные...

![](https://pictures.s3.yandex.net/resources/Untitled_1593896899.png)

Класс!

### Вынесите компонент Card

Ничего особенного, просто поддерживаем порядок. Компонент может пока иметь всего один пропс ```card```, в который целиком будет передаваться текущий элемент итерируемого массива.

### Показывайте полноразмерную картинку при клике

Снова становится интересно. Чтобы отображать большую картинку при клике на карточку нужно сделать несколько вещей, которые вы уже делали на прошлых шагах.

1. В компоненте ```App``` добавьте стейт-переменную ```selectedCard```. Значение этой переменной должно задаваться из нового обработчика ```handleCardClick``` и сбрасываться из уже существующего ```closeAllPopups```.
2. Значение ```selectedCard``` должно передаваться с помощью пропса ```card``` в компонент ```ImagePopup```, где оно будет использоваться для определения наличия CSS-класса видимости и задания адреса изображения в теге ```img```. Также у ```ImagePopup``` должен появиться пропс ```onClose```.
3. Обработчик ```handleCardClick``` должен вызываться из компонента ```Card```. Для этого его нужно «пробросить» в компонент ```Card``` сквозь компонент ```Main``` — в виде пропса ```onCardClick```. При этом, чтобы в него задавалось нужное значение с данными карточки, в компоненте ```Card``` должен появиться приблизительно такой код:

```javascript
function handleClick() {
  props.onCardClick(props.card);
}
  ```

Вот вы и подошли к финалу. Если вы всё сделали правильно... “you are breathtaking”!

![](https://pictures.s3.yandex.net/resources/12Untitled_1593896957.png)

### Заключение

Вы завершили первый спринт по «Реакту».

Поначалу новый подход может показаться непривычным, но скоро вы станете замечать, что код, написанный с использованием компонентного и декларативного подходов выглядит более лаконичным, а поддерживать и развивать его становится намного приятнее.

Что ж, пробегитесь ещё раз по коду вашего проекта, подкорректируйте код-стайл, проверьте на наличие ошибок и смело отправляйте работу на проверку!

В следующем спринте вы продолжите портировать этот проект на «Реакт» и добавите возможность редактировать пользовательские данные, создавать новые карточки и ставить «лайки». Ведь в конечном счёте... всё ради лайков!

### Чеклист

Не забудьте проверить себя по чеклисту: [https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-10/index.html](https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-10/index.html)
</details>

---
---
---
    
# Проектная работа 9
### Задание
<details>
<summary>Подробнее ...</summary>
# Проектная работа 9
В проектной работе этого спринта вы подключите проект Mesto к серверу.

![В этом спринте проект оживёт](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_4.18.50_PM_1592653422.png)

## Необходимая информация

Для выполнения задания этого спринта вам понадобится дополнительная информация — ваш личный токен и идентификатор вашей группы:

```javascript
c56e30dc-2883-4270-a59e-b2f7bae969c6 — так выглядит токен
cohort-42 — а так идентификатор группы 
```

Вы получите их в личных сообщениях в Slack. Если по какой-то причине вы не получили этих данных, напишите куратору.
Токен нужен для того, чтобы сервер умел различать пользователей. Он принадлежит только вам, не делитесь им с другими студентами.
При авторизации на каком-нибудь сайте, например, в социальной сети, обычно вводят логин и пароль. Эти логин и пароль отправляются на сервер, а сервер взамен присылает уникальный токен. Когда вы делаете к серверу новые запросы, они должны содержать этот токен, чтобы сервер понял, что запросы делаете именно вы.
Вы получили этот токен сразу. Мы пропустили шаг с обменом логина и пароля на токен. Иначе всю неделю пришлось бы потратить только на его реализацию.

## Как сделать запрос к серверу

Адрес сервера проекта Mesto: [https://mesto.nomoreparties.co.](https://mesto.nomoreparties.co.)

При каждом запросе нужно передавать токен и идентификатор группы. Вот пример запроса одного студента из группы с идентификатором ```cohort-42```:

```javascript
fetch('https://mesto.nomoreparties.co/v1/cohort-42/cards', {
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6'
  }
})
  .then(res => res.json())
  .then((result) => {
    console.log(result);
  });
  ```

Обратите внимание, что при запросе нужно передавать токен в заголовке ```authorization```. Это необходимое условие. Если не передать серверу токен или передать неправильный — сервер ответит ошибкой. Делайте это в каждом запросе.
Идентификатор группы должен быть в URL сразу после ```v1```. Всегда обращайтесь к своей группе. Если обратиться к чужой, сервер вернёт ошибку.

## 1. Загрузка информации о пользователе с сервера

Информация о пользователе должна подгружаться с сервера. Чтобы осуществить это, сделайте GET-запрос на URL (```cohortId``` замените на идентификатор вашей группы):

```javascript
GET https://mesto.nomoreparties.co/v1/cohortId/users/me 
```

При запросе не забудьте передать токен. Если запрос прошёл успешно, в ответе вы получите объект пользователя:

```javascript
{
  "name": "Jacques Cousteau",
  "about": "Sailor, researcher",
  "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
  "_id": "e20537ed11237f86bbb20ccb",
  "cohort": "cohort0"
} 
```

Используйте свойства name, about и avatar в соответствующих элементах шапки страницы. Свойство _id — это идентификатор пользователя, в данном случае вашего.

## 2. Загрузка карточек с сервера

Начальные карточки должны подгружаться с сервера. Для этого сделайте GET-запрос:

```javascript
GET https://mesto.nomoreparties.co/v1/cohortId/cards
```

В ответ придёт JSON с массивом карточек, которые загрузили студенты вашей группы:

```javascript
[
  {
    "likes": [],
    "_id": "5d1f0611d321eb4bdcd707dd",
    "name": "Байкал",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/baikal.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:10:57.741Z"
  },
  {
    "likes": [],
    "_id": "5d1f064ed321eb4bdcd707de",
    "name": "Архыз",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/arkhyz.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:11:58.324Z"
  }
]
```

Используйте этот массив при отображении предзагруженных карточек, а от предыдущего способа отображения первоначальных карточек избавьтесь.
У каждой карточки есть свойства ```name``` и ```link``` — это заголовок и ссылка на картинку — они понадобятся при отображении каждой отдельной карточки.
Как видите, у карточки также есть идентификатор — свойство ```_id```. Сейчас он вам не нужен, но скоро понадобится.

## 3. Редактирование профиля

Отредактированные данные профиля должны сохраняться на сервере. Для этого отправьте запрос методом PATCH:

```javascript
PATCH https://mesto.nomoreparties.co/v1/cohortId/users/me
```

В заголовках запроса, кроме токена, необходимо отправить Content-Type, а в теле — JSON с двумя свойствами — ```name``` и ```about```. Значениями этих свойств должны быть обновлённые данные пользователя. Вот пример такого запроса:

```javascript
fetch('https://mesto.nomoreparties.co/v1/cohortId/users/me', {
  method: 'PATCH',
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Marie Skłodowska Curie',
    about: 'Physicist and Chemist'
  })
});
```

Если обновление прошло успешно, в теле ответа от сервера вы получите обновлённые данные пользователя:

```javascript
{
  "name": "Marie Skłodowska Curie",
  "about": "Physicist and Chemist",
  "avatar": "https://pictures.s3.yandex.net/frontend-developer/common/ava.jpg",
  "_id": "e20537ed11237f86bbb20ccb",
  "cohort": "cohort0",
}
```

Метод PATCH обычно используют для обновления сущностей, уже существующих на сервере. Обновление информации о пользователе именно такой случай: пользователь уже есть, нужно просто обновить его данные.

## 4. Добавление новой карточки

Чтобы добавить на сервер новую карточку, отправьте POST-запрос:

```javascript
POST https://mesto.nomoreparties.co/v1/cohortId/cards
```

В заголовках запроса, кроме токена, необходимо отправить Content-Type, а в теле — JSON с двумя свойствами — ```name``` и ```link```. В name должно быть название создаваемой карточки, а в ```link``` — ссылка на картинку. Если запрос прошёл успешно, сервер вернёт ответ с объектом новой карточки:

```javascript
  {
    "likes": [],
    "_id": "5d1f0611d321eb4bdcd707dd",
    "name": "Байкал",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/baikal.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:10:57.741Z"
  },
```

## 5. Отображение количества лайков карточки

У каждой карточки есть свойство likes — оно содержит массив пользователей, лайкнувших карточку:

```javascript
{
  "likes": [],
  ...другие данные карточки
}
```

Сделайте так, чтобы на каждой карточке было написано, сколько у неё лайков:

![колличество лайков](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_4.18.50_PM_1592653422.png)

Для этого придётся сверстать дополнительный элемент. [Его дизайн есть в Фигме.](https://www.figma.com/file/PSdQFRHoxXJFs2FH8IXViF/JavaScript-9-sprint?node-id=0%3A1)

## 6. Попап удаления карточки

Удаление чего-то, как правило, безвозвратно. Поэтому перед этим действием стоит спросить пользователя, уверен ли он, что хочет удалить карточку. Для этого сделайте новый попап. Он должен открываться по клику на иконку удаления:

![Попап удаления карточки](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_4.57.34_PM_1592654068.png)

[Дизайн попапа есть в Фигме.](https://www.figma.com/file/PSdQFRHoxXJFs2FH8IXViF/JavaScript-9-sprint?node-id=0%3A1)

## 7. Удаление карточки

Прежде чем браться за работу с API, исправьте элемент карточки. Сделайте так, чтобы иконка удаления была только на созданных вами карточках, так как удалять чужие карточки нельзя.

![Если карточка создана не вами, на ней нет иконки корзины](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_4.18.50_PM_1592653422.png)

После того, как сделаете это, реализуйте функциональность удаления карточки. Карточка должна удаляться, если в попапе удаления карточки пользователь нажал «Да».
Чтобы удалить карточку, отправьте DELETE-запрос:

```javascript
DELETE https://mesto.nomoreparties.co/v1/cohortId/cards/cardId
```

Вместо cardId в URL нужно подставить параметр ```_id``` карточки, которую нужно удалить. ```_id``` каждой карточки есть в её JSON:

```javascript
{
  "likes": [],
  "_id": "5d1f0611d321eb4bdcd707dd", — вот он
  ...другие данные карточки
}
```

В итоге, запрос на удаление этой карточки должен выглядеть так:

```javascript
DELETE https://mesto.nomoreparties.co/v1/cohortId/cards/5d1f0611d321eb4bdcd707dd
```

## 8. Постановка и снятие лайка

Чтобы лайкнуть карточку, отправьте PUT-запрос:

```javascript
PUT https://mesto.nomoreparties.co/v1/cohortId/cards/likes/cardId
```

Чтобы убрать лайк, нужно отправить DELETE-запрос с тем же URL:

```javascript
DELETE https://mesto.nomoreparties.co/v1/cohortId/cards/likes/cardId
```

Вместо ```cardId``` в URL нужно подставить свойство ```_id``` соответствующей карточки.
В ответе придёт обновлённый JSON с карточкой. Массив лайков в нём будет уже обновлён.
При постановке и снятии лайка сердечко должно менять цвет, а счётчик лайков увеличиваться или уменьшаться.
Чтобы изменить количество лайков, нужно прибавить или отнять единицу от актуального количества. Рекомендуем брать это количество из ответа сервера, а не из вёрстки. Иначе возникнут ошибки, когда в одно и то же время два пользователя лайкнут одну карточку.

## 9. Обновление аватара пользователя

Чтобы сменить аватар, отправьте такой PATCH-запрос:

```javascript
PATCH https://mesto.nomoreparties.co/v1/cohortId/users/me/avatar
```

В теле запроса передайте JSON с единственным свойством — ```avatar```. Это свойство должно хранить ссылку на новый аватар. Если отправить не ссылку, сервер вернёт ошибку.
При наведении указателя мыши на аватар, на нём должна появляться иконка редактирования:

![иконка редактирования профиля](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_5.22.48_PM_1592654397.png)

А при клике, открываться форма. Эту форму нужно сделать. В ней должно быть одно поле — ссылка на новый аватар:

![форма редактирования аватара профиля](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_5.46.36_PM_1592654421.png)

Иконка редактирования аватара и форма загрузки [есть в Фигме.](https://www.figma.com/file/PSdQFRHoxXJFs2FH8IXViF/JavaScript-9-sprint?node-id=0%3A1)

## 10. Улучшенный UX всех форм

Поработайте над UX. При редактировании профиля уведомите пользователя о процессе загрузки, поменяв текст кнопки на: «Сохранение...», пока данные загружаются:

![процесс загрузки в форме](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_6.03.28_PM_1592654465.png)

Сделайте то же самое для формы добавления новой карточки и обновления аватара.

### Требования к коду

Для работы с API создайте класс ```Api```. Все запросы должны быть методами этого класса:

```javascript
class Api {
  constructor(options) {
    // тело конструктора
  }

  getInitialCards() {
    // ...
  }

  // другие методы работы с API
}

const api = new Api({
  baseUrl: 'https://mesto.nomoreparties.co/v1/cohort-42',
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6',
    'Content-Type': 'application/json'
  }
});
```

### Общие комментарии

**1. Не забывайте проверять, всё ли в порядке с ответом.** Можно использовать ```res.ok``` или ```res.status```:

```javascript
getInitialCards() {
  return fetch('https://mesto.nomoreparties.co/v1/cohort-42/cards', {
    headers: {
      authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6'
    }
  })
    .then(res => {
      if (res.ok) {
        return res.json();
      }
    });
}
```

**2. Учитывайте случай, когда сервер вернул ошибку.**

```javascript
getInitialCards() {
  return fetch('https://mesto.nomoreparties.co/v1/cohort-42/cards', {
    headers: {
      authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6'
    }
  })
    .then(res => {
      if (res.ok) {
        return res.json();
      }

      // если ошибка, отклоняем промис
      return Promise.reject(`Ошибка: ${res.status}`);
    });
}
```

**3. Обрабатывайте ошибки, попадающие в catch.** Если запрос не ушёл на сервер, или тот не ответил, сработает блок ```catch```. Обрабатывайте ошибку внутри этого блока. Если нет времени писать сложную логику, хотя бы просто выведите ошибку в консоль.

```javascript
api.getInitialCards()
  .then((result) => {
    // обрабатываем результат
  })
  .catch((err) => {
    console.log(err); // выведем ошибку в консоль
  });
  ```

**4. Пользуйтесь вкладкой Network для просмотра запросов.** При отправке запросов держите вкладку Network открытой. Отфильтруйте в ней XHR запросы. Это позволит оперативно следить, что приходит в ответе от сервера.

### Если проблемы с «Фигмой»

У «Фигмы» есть ограничение на количество одновременных посетителей. Может оказаться, что в макет зашло слишком много студентов, и «Фигма» вас не пустит. Чтобы этого избежать, скачайте копию макета к себе. Легче всего это сделать из [приложения Figma для компьютера](https://www.figma.com/downloads/). После авторизации вы сможете скачать копию проекта с расширением ```.fig```.

![Сохранение проекта на компьютер](https://pictures.s3.yandex.net/resources/Untitled_1592654537.png)

Импортировать файл обратно в «Фигму» можно нажав иконку ”import“ в правом верхнем углу.

![Импорт файла в «Фигму»](https://pictures.s3.yandex.net/resources/import_1592654673.png)

Файл загрузится на вашу личную доску. Комментарии пропадут, но всё необходимое для работы над макетом всегда будет под рукой.

### Чеклист

Не забудьте проверить себя по чеклисту: [https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-9/index.html](https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-9/index.html)
</details>

---
---
---


# Проектная работа № 8
## Mesto
### Задание
<details>
<summary>Подробнее ...</summary>
# Проектная работа 8
В проектной работе этого спринта вы продолжите заниматься рефакторингом. Создадите ещё несколько классов и настроите связи между ними. В завершении проектной работы нужно будет настроить сборку проекта Вебпаком.
## Создайте класс ```Section```
Создайте класс ```Section```, который отвечает за отрисовку элементов на странице. Этот класс:
- Первым параметром конструктора принимает объект с двумя свойствами: ```items``` и ```renderer```. Свойство ```items``` — это массив данных, которые нужно добавить на страницу при инициализации класса. Свойство ```renderer``` — это функция, которая отвечает за создание и отрисовку данных на странице.
- Второй параметр конструктора — селектор контейнера, в который нужно добавлять созданные элементы.
Содержит публичный метод, который отвечает за отрисовку всех элементов. Отрисовка каждого отдельного элемента должна осуществляться функцией ```renderer```.
- Содержит публичный метод ```addItem```, который принимает DOM-элемент и добавляет его в контейнер.
У класса ```Section``` нет своей разметки. Он получает разметку через функцию-колбэк и вставляет её в контейнер.
## Создайте класс ```Popup```
Создайте класс Popup, который отвечает за открытие и закрытие попапа. Этот класс:
- Принимает в конструктор единственный параметр — селектор попапа.
- Содержит публичные методы ```open``` и ```close```, которые отвечают за открытие и закрытие попапа.
- Содержит приватный метод ```_handleEscClose```, который содержит логику закрытия попапа клавишей Esc.
- Содержит публичный метод ```setEventListeners```, который добавляет слушатель клика иконке закрытия попапа.
## Создайте класс PopupWithImage
Создайте класс ```PopupWithImage```, который наследует от ```Popup```. Этот класс должен перезаписывать родительский метод ```open```. В методе ```open``` класса ```PopupWithImage``` нужно вставлять в попап картинку и атрибут ```src``` изображения и подпись к картинке.
## Создайте класс PopupWithForm
Создайте класс ```PopupWithForm```, который наследует от ```Popup```. Этот класс:
- Кроме селектора попапа принимает в конструктор колбэк сабмита формы.
- Содержит приватный метод ```_getInputValues```, который собирает данные всех полей формы.
- Перезаписывает родительский метод ```setEventListeners```. Метод ```setEventListeners``` класса ```PopupWithForm``` должен не только добавлять обработчик клика иконке закрытия, но и добавлять обработчик сабмита формы.
- Перезаписывает родительский метод ```close```, так как при закрытии попапа форма должна ещё и сбрасываться.
Для каждого попапа создавайте свой экземпляр класса ```PopupWithForm```.
## Создайте класс ```UserInfo```
Класс ```UserInfo``` отвечает за управление отображением информации о пользователе на странице. Этот класс:
- Принимает в конструктор объект с селекторами двух элементов: элемента имени пользователя и элемента информации о себе.
- Содержит публичный метод ```getUserInfo```, который возвращает объект с данными пользователя. Этот метод пригодится когда данные пользователя нужно будет подставить в форму при открытии.
- Содержит публичный метод ```setUserInfo```, который принимает новые данные пользователя и добавляет их на страницу.
## Преобразуйте класс ```Card```
Свяжите класс ```Card``` c попапом. Сделайте так, чтобы Card принимал в конструктор функцию ```handleCardClick```. Эта функция должна открывать попап с картинкой при клике на карточку.
## Создайте файл ```.gitignore```
Следующим заданием будет инициализация npm и настройка Webpack. Это значит, что в проекте появятся папки ```node_modules``` и ```dist```. Эти папки не принято добавлять в git-репозиторий, так как любой разработчик может сгенерировать их у себя на компьютере. Для этого достаточно иметь ```package.json```.
Чтобы ```node_modules``` и ```dist``` не попадали в репозиторий, нужно научить git их игнорировать. Для этого в корне проекта создайте файл ```.gitignore``` и добавьте в него две строки:

```javascript
node_modules
dist
```

Сохраните файл. Теперь git не будет обращать внимание на эти папки.

Примечание: перед тем, как отправить проект на код-ревью, добавьте ```node_modules``` в файл ```.gitignore```. Иначе проект не загрузится или ревьюер отклонит его от проверки.
## Настройте сборку Вебпаком
1. Инициализируйте **npm** в проекте.
2. Установите ```webpack```, ```webpack-cli``` и ```webpack-dev-server```.
3. Настройте две сборки: ```build``` и ```dev```. Создайте соответствующие скрипты в ```package.json```. Скрипт ```build``` должен пересоздавать папку ```dist``` с собранным проектом. Скрипт ```dev``` запускать проект на локальном сервере.
4. Настройте минификацию и транспиляцию JS бабелем. Из ```index.html``` уберите теги ```script``` с подключением скриптов. Вебпак должен собирать весь JavaScript в один файл и автоматически добавлять в HTML тег script со ссылкой на него.
5. Настройте обработку CSS: в HTML больше не должно быть тега ```link``` со ссылкой на CSS-файл. За обработку и подключение CSS должен отвечать Webpack.
6. Настройте минификацию CSS и автоматическое добавление вендорных префиксов.
7. Настройте обработку изображений и шрифтов.
8. Настройте обработку HTML: если в HTML есть ссылки на локальные картинки, при сборке всё должно работать.

HTML, CSS и JS-файлы должны быть в папке ```src```. Итоговая структура проекта должна быть такой:

![Итоговая структура проекта](https://pictures.s3.yandex.net/resources/iMac_-_3_1591519690.png)

Требования к коду
- Добавьте в проект классы ```Section```, ```Popup```, ```PopupWithForm```, ```PopupWithImage``` и ```UserInfo```. Каждый из них выполняет строго одну задачу. Всё, что относится к решению этой задачи, находится внутри класса.
- Если классы нужно связать друг с другом, делайте это передаваемой в конструктор функцией-колбэком.
- Все классы должны быть вынесены в отдельные файлы.
- В файле ```index.js``` должно остаться только создание классов и добавление некоторых обработчиков.

## Чеклист
Не забудьте проверить себя по чеклисту: [https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-8/index.html](https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-8/index.html)
</details>

---
---
---
