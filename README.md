# Проектная работа 11

## Mesto

### Блоки

* **header** - здесь содержится только логотип и нижнее подчеркивание блока
* **main** - секция разметки основного контента
    * **profile** - секция в которой:
    - можно изменить с отправкой на сервер:
        - аватар профиля
        - название профиля
        - описание профиля
    - создать новую карточку:
        - добавив заголовок карточке
        - добавив ссылку на картинку
    * **grid** - секция с карточками, в каждой карточке содержиться:
        - фото(картинка карточки)
        - заголовок
        - возможность поставить лайк
        - возможность открытия(увеличения) фото с описанием под ним
* **footer** - копирайт

* **popups** (диалоговые окна):
    - popup при клике на аватар - содержит поле ввода ссылки на смену аватара
    - popup при клике на редактирование профиля - содержит поля ввода заголовка и описания профиля
    - popup при клике на кнопку добавления - содержит поля ввода заголовка и ссылки на картинку
    - popup при клике на карточку - содержит картинку в полном масштабе и описание с альтернативным текстом

**Инфо**

Это небольшой проект-портфолио, созданный под разные экраны устройств, с точками перелома: 677px, 882px, 1200px.

* [Ссылки на макеты в Figma]
    * 4-й проект: ( https://www.figma.com/file/StZjf8HnoeLdiXS7dYrLAh/JavaScript.-Sprint-4 )
    * 5-й проект: ( https://www.figma.com/file/nlYpT4VhFiwimn2YlncrcF/JavaScript.-Sprint-5?node-id=90%3A311 )
    * 6-й проект: ( https://www.figma.com/file/XNaGNEZD5NEjeyJzAT4gMb/JavaScript.-Sprint-6 )
    * 7..11-й проект: (https://www.figma.com/file/LD0gRfv5QlfDNrpOb2wus3/Russia?node-id=131%3A541)

**GitHub Pages**

* [Ссылка на проект](https://stanislav-vasilevich.github.io/mesto/)

## Технологии, новые теги и языки

Проект создан на React

* в этой 11-й проектной работе я реализовал отправку данных на сервер для динамического изменения нужных данных(карточек, аватара, профиля пользователя):
    - ```GET```
    - ```POST```
    - ```PUT```
    - ```PUTCH```
    - ```DELETE```

Теперь все данные приходят динамически с сервера.

* использовал state для внутренних состояний отдельных составных компонентов веб-приложения.

### Задание
<details>
<summary>Подробнее ...</summary>

# Проектная работа 11

В этой проектной работе вы продолжите портировать проект Mesto на «Реакт» и научитесь отправлять данные форм и другую информацию в API.

### 1. Контекст текущего пользователя

Данные текущего пользователя нужны в разных местах приложения: например, чтобы определить может ли пользователь удалять карточку.

Мы будем использовать контекст, чтобы все компоненты приложения могли получить доступ к этим данным.

## Создайте стейт ```currentUser``` в корневом компоненте

В компоненте ```App``` создайте переменную состояния ```currentUser``` и эффект при монтировании, который будет вызывать ```api.getUserInfo``` и обновлять стейт-переменную из полученного значения.

Мы уже делали аналогичную операцию в ```Main```, хотя там мы и использовали сразу три стейт-переменных вместо одной. Скоро их можно будет удалить.

## Создайте объект контекста и используйте провайдер

Создайте файл ```src/contexts/CurrentUserContext.js``` и экспортируйте из него новый объект контекста.

Импортируйте этот объект в ```App``` и используйте его провайдер: «оберните» в него всё текущее содержимое корневого компонента. В качестве значения контекста для провайдера используйте ```currentUser```.

## Используйте контекст в ```Main```

В зависимости от того, какой тип имеет ваш компонент Main (функциональный или классовый), используйте соответствующий подход, чтобы подписать его на ```CurrentUserContext``` и получить значение контекста.

Теперь у вас есть объект текущего пользователя, полученный из контекста. Используйте его поля ```name```, ```about``` и ```avatar``` вместо стейт-переменных ```userName```, ```userDescription``` и ```userAvatar```, соответственно. Эти переменные, а также вызов ```api.getUserInfo``` внутри ```Main``` больше не нужны — их можно удалить.

## Используйте контекст в ```Card```

Аналогичным образом подпишите на контекст компонент ```Card```.

Теперь можно определить, должна ли в текущей карточке показываться иконка удаления. Для этого можно использовать следующий код:

```jsx
// Определяем, являемся ли мы владельцем текущей карточки
const isOwn = card.owner._id === currentUser._id;

// Создаём переменную, которую после зададим в `className` для кнопки удаления
const cardDeleteButtonClassName = (
  `card__delete-button ${isOwn ? 'card__delete-button_visible' : 'card__delete-button_hidden'}`
);
```

Похожий код поможет определить, поставили ли мы уже «лайк» этой карточке:

```jsx
// Определяем, есть ли у карточки лайк, поставленный текущим пользователем
const isLiked = card.likes.some(i => i._id === currentUser._id);

// Создаём переменную, которую после зададим в `className` для кнопки лайка
const cardLikeButtonClassName = `...`;
```

Теперь нужно научиться отправлять данные в API и обновлять их локальные значения.

### 2. Лайки и удаление карточек

## Добавьте поддержку лайков и дизлайков

Так как список карточек находится в компоненте ```Main``` (в виде переменной состояния ```cards```), там и разместим код, который будет вызываться при клике на лайк. Для этого добавьте функцию ```handleCardLike``` со следующим содержимым:

```jsx
function handleCardLike(card) {
    // Снова проверяем, есть ли уже лайк на этой карточке
    const isLiked = card.likes.some(i => i._id === currentUser._id);
    
    // Отправляем запрос в API и получаем обновлённые данные карточки
    api.changeLikeCardStatus(card._id, !isLiked).then((newCard) => {
        setCards((state) => state.map((c) => c._id === card._id ? newCard : c));
    });
}
```

Теперь нужно добавить пропс ```onCardLike``` для компонента ```Card``` и задать в него эту функцию. Также добавьте в ```Card``` обработчик клика ```handleLikeClick``` и вызовите из него ```onCardLike``` с аргументом ```card``` — по аналогии с уже имеющимся обработчиком ```handleClick```.

Если всё сделано правильно, вы увидите магию декларативного подхода: после отправки данных на сервер не нужно обновлять DOM. Нужно только внести изменения в стейт, и интерфейс обновится автоматически.

## Добавьте поддержку удаления карточки

По аналогии с предыдущим пунктом добавьте функцию ```handleCardDelete``` в ```Main```, а также пропс ```onCardDelete``` и обработчик ```handleDeleteClick``` в ```Card```.

После запроса в API, обновите стейт ```cards``` с помощью метода ```filter```: создайте копию массива, исключив из него удалённую карточку.

Пока не будем добавлять поддержку всплывающего окна подтверждения. Будьте осторожны, удаляя любимые карточки!

```text
Если вы удалили все свои карточки, используйте версию приложения без «Реакта», чтобы добавить карточки. В конце проектной работы вы добавите эту функцию и в новую версию.
```

### 3. Редактирование профиля

## Рефакторинг: Вынесите компонент ```EditProfilePopup```

Чтобы добавить обработку формы в окно редактирования профиля, сначала вынесите его в отдельный компонент из ```App```: перенесите тег ```PopupWithForm``` вместе с содержимым. Добавьте новому компоненту пропсы ```isOpen``` и ```onClose``` и пробрасывайте их в ```PopupWithForm```. После этого в ```App``` останется такой код:

```jsx
<EditProfilePopup isOpen={isEditProfilePopupOpen} onClose={closeAllPopups} />
```

## Добавьте управляемые компоненты

Внутри ```EditProfilePopup``` добавьте стейт-переменные name и ```description``` и привяжите их к полям ввода, сделав их управляемыми. Не забудьте про обработчики ```onChange```.

## Используйте значения по умолчанию из ```currentUser```

Чтобы подставить в форму текущие значения, подпишитесь на контекст. Затем создайте эффект, который будет обновлять переменные состояния при изменении контекста. Например:

```jsx
// Подписка на контекст
const currentUser = React.useContext(CurrentUserContext);

// После загрузки текущего пользователя из API
// его данные будут использованы в управляемых компонентах.
React.useEffect(() => {
  setName(currentUser.name);
  setDescription(currentUser.about);
}, [currentUser]);
```

## Сохраняйте данные в API

Добавьте компоненту ```PopupWithForm``` пропс ```onSubmit``` и задайте его в качестве значения одноимённого атрибута тега ```form```.

Теперь в компоненте ```EditProfilePopup``` можно добавить обработчик ```handleSubmit```. Однако, мы не можем делать запрос в API прямо в этом обработчике, потому что после его завершения нужно обновить переменную состояния ```currentUser```, которая находится ещё выше — в компоненте ```App```. Поэтому эта функция будет содержать следующий код:

```jsx
function handleSubmit(e) {
  // Запрещаем браузеру переходить по адресу формы
  e.preventDefault();

  // Передаём значения управляемых компонентов во внешний обработчик
  props.onUpdateUser({
    name,
    about: description,
  });
}
```

Теперь нужно создать обработчик в ```App```. Назовите его ```handleUpdateUser``` и задайте его в виде нового пропса ```onUpdateUser``` для компонента ```EditProfilePopup```. Внутри этого обработчика вызовите ```api.setUserInfo```. После завершения запроса обновите стейт ```currentUser``` из полученных данных и закройте все модальные окна.

Если вы сделали всё правильно, при нажатии кнопки «Сохранить» данные должны отправляться на сервер, а интерфейс должен автоматически обновляться. Надеемся, у вас получилось!

### 4. Редактирование аватара

## Рефакторинг: Вынесите компонент ```EditAvatarPopup```

В ```App``` должен остаться код:

```jsx
<EditAvatarPopup isOpen={isEditAvatarPopupOpen} onClose={closeAllPopups} />
```

## Используйте реф

На этот раз вместо управляемых компонентов используйте реф, чтобы получить прямой доступ к DOM-элементу инпута и его значению.

В остальном сделайте всё по аналогии с редактированием профиля. Функция ```handleSubmit``` может выглядеть так:

```jsx
function handleSubmit(e) {
  e.preventDefault();

  onUpdateAvatar({
    avatar: /* Значение инпута, полученное с помощью рефа */,
  });
}
```

В ```App``` добавьте ```handleUpdateAvatar```, вызывающий ```a```pi.setUserAvatar```. Не забудьте обновлять аватар локально после завершения запроса.

Отлично, осталось совсем чуть-чуть!

### 5. Добавление новой карточки

Пришло время для последней и самой главной функции.

## Поднимите стейт ```cards```

Чтобы получить возможность изменять локальный список карточек из попапа, нужно снова осуществить поднятие стейта. На этот раз перенесите всё, что касается переменной cards из ```Main``` в ```App```. А именно: саму переменную, эффект с API-запросом ```api.getCardList```, обработчики ```handleCardLike``` и ```handleCardDelete```. При этом в ```Main``` они должны передаваться в виде пропсов ```cards```, ```onCardLike``` и ```onCardDelete```. Проверьте, что ничего не сломалось.

## Рефакторинг

Привычным жестом вынесите новый компонент ```AddPlacePopup``` из соответствующего кода в ```App```.

## Сохраните данные

Добавьте обработчик ```handleAddPlaceSubmit```. После завершения API-запроса внутри него обновите стейт ```cards``` с помощью расширенной копии текущего массива — используйте оператор ```...```:

```jsx
setCards([newCard, ...cards]);
```

Не забудьте про ```handleSubmit``` и ```onAddPlace``` для нового компонента ```AddPlacePopup```. В этот раз вы можете использовать как управляемые компоненты, так и рефы для получения значений инпутов — на ваше усмотрение.

Если всё работает правильно, новые карточки должны появляться в конце списка. Красота!

## Заключение

После того, как сделаете все задания, в работе, по-прежнему, будет что улучшить. Например, сделать валидацию форм и индикаторы загрузки запросов. Сейчас они всё ещё работают за счёт императивного ```renderLoading``` из ```utils.js```. Также можно добавить всплывающие подтверждения для удаления карточек. Попробуйте сделать это самостоятельно, если чувствуете в себе силы.

Кроме того, когда справитесь с заданиями, пробегитесь по коду и ещё раз проверьте себя: возможно, что-то ещё можно «причесать» или украсить.

### Чеклист

Не забудьте проверить себя по чеклисту: [https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-11/index.html](https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-11/index.html)
</details>

---
---
---

# Проектная работа 10
### Задание
<details>
<summary>Подробнее ...</summary>

### 1. Создайте новый проект на Create React App

В этой проектной работе вы начнёте портировать проект Mesto на «Реакт».

После настройки и запуска нового проекта вы увидите стандартную заставку:

![](https://pictures.s3.yandex.net/resources/Untitled_1593896697.png)

### 2. Ведите работу в новом репозитории

При создании нового проекта Create React App инициализирует локальный git-репозиторий. Кроме этого, как только вы перешли в урок проектной работы, удалённый репозиторий ```mesto-react``` скопировался в ваш аккаунт на «Гитхабе». Локальный и удалённый репозитории нужно связать.

Для этого скопируйте адрес удалённого репозитория:

![](https://pictures.s3.yandex.net/resources/github_mm_08_1603114903.jpg)

И свяжите локальный репозиторий с удалённым командой git remote add. Для этого, находясь в папке проекта, введите:

```javascript
git remote add origin адрес_репозитория 
```

```git push -u -f origin main ```

Флаг `````-u````` говорит о том, что локальная ветка ```main``` должна отслеживать удалённую. Такой флаг обычно используют при первом пуше, когда локальная и удалённая ветки ещё не связаны.

Флаг `````-f````` означает, что все удалённые коммиты указанной ветки необходимо переписать локальными. Этот флаг нужно использовать с осторожностью. Мы прибегаем к нему только для инициализации репозитория, а в дальнейшем использовать не будем.

### 3. Портируйте разметку
### Скопируйте HTML и конвертируйте его в JSX

В старом проекте был корневой элемент `````.page__content`````. Замените им содержимое компонента ```App```. Не забывайте, что JSX и HTML — не совсем одно и то же.

Если вы всё сделали правильно, вы должны увидеть промежуточный результат:

![](https://pictures.s3.yandex.net/resources/Untitled_1_1593896726.png)

Здорово, но могло бы быть и покрасивее. Кажется, нужно перенести стили.

### Портируйте стили

Стили компонента ```App.css``` больше не понадобятся — этот файл можно удалить.

Скопируйте папки ```blocks```, ```images``` и ```vendor``` из старого проекта. В новом проекте содержимое файла ```index.css``` замените на содержимое из ```pages/index.css```:

![](https://pictures.s3.yandex.net/resources/Untitled_1593896766.png)

Уже что-то, но не хватает логотипа. Импортируйте его правильным образом и подставьте полученный путь в JSX:

![](https://pictures.s3.yandex.net/resources/Untitled11_1593896800.png)

### 4. Вынесите первые компоненты

Пора начать наводить порядок в коде. Создайте папку ```src/components``` и перенесите в неё главный компонент приложения ```App.js```.

Создайте новый файл ```Header.js``` и вынесите в него элемент ```<header>``` в виде отдельного компонента. Импортируйте и используйте этот компонент внутри ```App```.

Аналогичным образом вынесите компоненты ```Main``` и ```Footer```.

Отлично: мы немного «разгрузили» основной компонент ```App```, хотя в нём всё ещё довольно много кода.

### 5. Настройте работу попапов

### Добавьте императивные обработчики

Чтобы добавить первую интерактивность, а заодно проверить, правильно ли вы портировали разметку попапов, внутри компонента ```Main``` добавьте следующие обработчики:

- ```handleEditAvatarClick```
- ```handleEditProfileClick```
- ```handleAddPlaceClick```

Здесь мы немного схитрим: внутри этих обработчиков временно используйте привычный императивный подход (с ```querySelector``` и ```classList.add```), чтобы задавать CSS-класс ```popup_is-opened``` элементу нужного попапа.

Теперь присвойте эти обработчики нужным элементам в JSX и убедитесь, что все три попапа открываются:

![](https://pictures.s3.yandex.net/resources/Untitled_1593896824.png)

Вскоре вы сможете перейти к декларативному подходу, но сперва нужно всё подготовить.

### Вынесите общий компонент попапов

Создайте компонент ```PopupWithForm``` и используйте его, чтобы вынести общий код следующих попапов:

- «Редактировать профиль»
- «Новое место»
- «Обновить аватар»
- «Вы уверены?»

В этих попапах много общей разметки: элементы внешнего и внутреннего контейнера, сама форма, заголовок и две кнопки. Вся общая разметка должна оказаться в новом компоненте. Извне должны будут передаваться только текст заголовка и идентификатор формы (в виде строк). Для этого добавьте соответствующие пропсы ```title``` и ```name``` и подставляйте их значения в JSX.

**Замечание 1.** Чтобы правильно подставить ```name``` в CSS-класс контейнера используйте следующую конструкцию:

```javascript
className={`popup popup_type_${props.name}`} 
```

**Замечание 2.** Значение пропса ```name``` будет использоваться не только в имени CSS-класса контейнера, но и для атрибута ```name``` тега ```form```.

Кроме заголовка и идентификатора в компонент ```PopupWithForm``` будет передаваться вложенное содержимое в виде JSX-разметки, отличающейся для всех четырёх попапов. Внутри самого компонента оно будет доступно через специальный пропс ```children```, который также должен быть подставлен в нужном месте в JSX.

### Вынесите компонент ```ImagePopup```

Здесь всё просто, этот компонент пока не имеет пропсов и вложенного содержимого.

### Декларативный подход

Начинается самое интересное. Для начала перенесите добавленные обработчики событий из компонента ```Main``` в компонент ```App```. При этом, чтобы они продолжали вызываться из компонента ```Main```, передавайте их в последний с помощью новых пропсов ```onEditProfile```, ```onAddPlace``` и ```onEditAvatar```.

Чтобы правильно реализовать декларативный подход, в компоненте ```App``` также должны появиться следующие переменные состояния, отвечающие за видимость трёх попапов:

- isEditProfilePopupOpen
- isAddPlacePopupOpen
- isEditAvatarPopupOpen

Теперь вы можете заменить императивный код в обработчиках событий на код, который будет изменять значения соответствующих переменных состояния, задавая в них значение ```true```.

Последнее, что нужно сделать, — добавить в компонент ```PopupWithForm``` пропc ```isOpen```, на основе которого в JSX будет задаваться CSS-класс, отвечающий за видимость попапа.

Наконец, в коде ```App``` значение ```isOpen``` каждого из трёх попапов должно задаваться с помощью соответствующей переменной состояния.

Если вы всё сделали правильно, попапы снова должны открываться, но теперь они управляются стейт-переменными — самый настоящий декларативный подход!

### Закрытие попапов

По аналогии со всеми предыдущими действиями реализуйте закрытие попапов. Вам поможет новый пропс ```onClose``` компонента ```PopupWithForm``` и его обработчик, который должен находиться внутри ```App``` и должен называться ```closeAllPopups```.

### 6. Подключите API

### Портируйте модуль API

Скопируйте файлы ```api.js``` и ```utils.js``` из старого проекта и положите их рядом в папке ```src/utils```.

Прямо внутри ```api.js``` создайте экземпляр класса ```Api``` с нужными параметрами (включая ваш токен) и экспортируйте этот экземпляр вместо самого класса.

### Используйте стейт для данных из API

В компоненте ```Main``` добавьте переменные состояния ```userName```, ```userDescription``` и ```userAvatar```. Используйте их в JSX.

Импортируйте модуль ```api``` и добавьте эффект, вызываемый при монтировании компонента, который будет совершать запрос в API за пользовательскими данными. После получения ответа задавайте полученные данные в соответствующие переменные состояния.

```Замечание.``` Чтобы подставить URL аватара в контейнер используйте такой код:

```javascript
style={{ backgroundImage: `url(${userAvatar})` }} 
```

Ура! Наконец-то должны появиться ваши сохранённые данные:

![](https://pictures.s3.yandex.net/resources/11Untitled_1593896872.png)

Ещё немного, и вы сможете увидеть карточки добавленных мест.

### 7. Настройте карточки мест

### Добавьте запрос к API

Добавьте ещё одну переменную стейта ```cards``` с пустым массивом в качестве значения по умолчанию. Добавьте второй запрос к API за соответствующими данными.

Из старого проекта скопируйте разметку карточки, находящуюся внутри тега ```template```, и используйте её внутри JSX-итерации по массиву ```cards```. Используйте подстановку данных элемента массива в JSX, чтобы вывести название карточки, количество лайков и указать URL изображения (как и прежде с помощью атрибута ```style```).

Немного подождите, пока загрузятся данные...

![](https://pictures.s3.yandex.net/resources/Untitled_1593896899.png)

Класс!

### Вынесите компонент Card

Ничего особенного, просто поддерживаем порядок. Компонент может пока иметь всего один пропс ```card```, в который целиком будет передаваться текущий элемент итерируемого массива.

### Показывайте полноразмерную картинку при клике

Снова становится интересно. Чтобы отображать большую картинку при клике на карточку нужно сделать несколько вещей, которые вы уже делали на прошлых шагах.

1. В компоненте ```App``` добавьте стейт-переменную ```selectedCard```. Значение этой переменной должно задаваться из нового обработчика ```handleCardClick``` и сбрасываться из уже существующего ```closeAllPopups```.
2. Значение ```selectedCard``` должно передаваться с помощью пропса ```card``` в компонент ```ImagePopup```, где оно будет использоваться для определения наличия CSS-класса видимости и задания адреса изображения в теге ```img```. Также у ```ImagePopup``` должен появиться пропс ```onClose```.
3. Обработчик ```handleCardClick``` должен вызываться из компонента ```Card```. Для этого его нужно «пробросить» в компонент ```Card``` сквозь компонент ```Main``` — в виде пропса ```onCardClick```. При этом, чтобы в него задавалось нужное значение с данными карточки, в компоненте ```Card``` должен появиться приблизительно такой код:

```javascript
function handleClick() {
  props.onCardClick(props.card);
}
  ```

Вот вы и подошли к финалу. Если вы всё сделали правильно... “you are breathtaking”!

![](https://pictures.s3.yandex.net/resources/12Untitled_1593896957.png)

### Заключение

Вы завершили первый спринт по «Реакту».

Поначалу новый подход может показаться непривычным, но скоро вы станете замечать, что код, написанный с использованием компонентного и декларативного подходов выглядит более лаконичным, а поддерживать и развивать его становится намного приятнее.

Что ж, пробегитесь ещё раз по коду вашего проекта, подкорректируйте код-стайл, проверьте на наличие ошибок и смело отправляйте работу на проверку!

В следующем спринте вы продолжите портировать этот проект на «Реакт» и добавите возможность редактировать пользовательские данные, создавать новые карточки и ставить «лайки». Ведь в конечном счёте... всё ради лайков!

### Чеклист

Не забудьте проверить себя по чеклисту: [https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-10/index.html](https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-10/index.html)
</details>

---
---
---
    
# Проектная работа 9
### Задание
<details>
<summary>Подробнее ...</summary>
# Проектная работа 9
В проектной работе этого спринта вы подключите проект Mesto к серверу.

![В этом спринте проект оживёт](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_4.18.50_PM_1592653422.png)

## Необходимая информация

Для выполнения задания этого спринта вам понадобится дополнительная информация — ваш личный токен и идентификатор вашей группы:

```javascript
c56e30dc-2883-4270-a59e-b2f7bae969c6 — так выглядит токен
cohort-42 — а так идентификатор группы 
```

Вы получите их в личных сообщениях в Slack. Если по какой-то причине вы не получили этих данных, напишите куратору.
Токен нужен для того, чтобы сервер умел различать пользователей. Он принадлежит только вам, не делитесь им с другими студентами.
При авторизации на каком-нибудь сайте, например, в социальной сети, обычно вводят логин и пароль. Эти логин и пароль отправляются на сервер, а сервер взамен присылает уникальный токен. Когда вы делаете к серверу новые запросы, они должны содержать этот токен, чтобы сервер понял, что запросы делаете именно вы.
Вы получили этот токен сразу. Мы пропустили шаг с обменом логина и пароля на токен. Иначе всю неделю пришлось бы потратить только на его реализацию.

## Как сделать запрос к серверу

Адрес сервера проекта Mesto: [https://mesto.nomoreparties.co.](https://mesto.nomoreparties.co.)

При каждом запросе нужно передавать токен и идентификатор группы. Вот пример запроса одного студента из группы с идентификатором ```cohort-42```:

```javascript
fetch('https://mesto.nomoreparties.co/v1/cohort-42/cards', {
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6'
  }
})
  .then(res => res.json())
  .then((result) => {
    console.log(result);
  });
  ```

Обратите внимание, что при запросе нужно передавать токен в заголовке ```authorization```. Это необходимое условие. Если не передать серверу токен или передать неправильный — сервер ответит ошибкой. Делайте это в каждом запросе.
Идентификатор группы должен быть в URL сразу после ```v1```. Всегда обращайтесь к своей группе. Если обратиться к чужой, сервер вернёт ошибку.

## 1. Загрузка информации о пользователе с сервера

Информация о пользователе должна подгружаться с сервера. Чтобы осуществить это, сделайте GET-запрос на URL (```cohortId``` замените на идентификатор вашей группы):

```javascript
GET https://mesto.nomoreparties.co/v1/cohortId/users/me 
```

При запросе не забудьте передать токен. Если запрос прошёл успешно, в ответе вы получите объект пользователя:

```javascript
{
  "name": "Jacques Cousteau",
  "about": "Sailor, researcher",
  "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
  "_id": "e20537ed11237f86bbb20ccb",
  "cohort": "cohort0"
} 
```

Используйте свойства name, about и avatar в соответствующих элементах шапки страницы. Свойство _id — это идентификатор пользователя, в данном случае вашего.

## 2. Загрузка карточек с сервера

Начальные карточки должны подгружаться с сервера. Для этого сделайте GET-запрос:

```javascript
GET https://mesto.nomoreparties.co/v1/cohortId/cards
```

В ответ придёт JSON с массивом карточек, которые загрузили студенты вашей группы:

```javascript
[
  {
    "likes": [],
    "_id": "5d1f0611d321eb4bdcd707dd",
    "name": "Байкал",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/baikal.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:10:57.741Z"
  },
  {
    "likes": [],
    "_id": "5d1f064ed321eb4bdcd707de",
    "name": "Архыз",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/arkhyz.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:11:58.324Z"
  }
]
```

Используйте этот массив при отображении предзагруженных карточек, а от предыдущего способа отображения первоначальных карточек избавьтесь.
У каждой карточки есть свойства ```name``` и ```link``` — это заголовок и ссылка на картинку — они понадобятся при отображении каждой отдельной карточки.
Как видите, у карточки также есть идентификатор — свойство ```_id```. Сейчас он вам не нужен, но скоро понадобится.

## 3. Редактирование профиля

Отредактированные данные профиля должны сохраняться на сервере. Для этого отправьте запрос методом PATCH:

```javascript
PATCH https://mesto.nomoreparties.co/v1/cohortId/users/me
```

В заголовках запроса, кроме токена, необходимо отправить Content-Type, а в теле — JSON с двумя свойствами — ```name``` и ```about```. Значениями этих свойств должны быть обновлённые данные пользователя. Вот пример такого запроса:

```javascript
fetch('https://mesto.nomoreparties.co/v1/cohortId/users/me', {
  method: 'PATCH',
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Marie Skłodowska Curie',
    about: 'Physicist and Chemist'
  })
});
```

Если обновление прошло успешно, в теле ответа от сервера вы получите обновлённые данные пользователя:

```javascript
{
  "name": "Marie Skłodowska Curie",
  "about": "Physicist and Chemist",
  "avatar": "https://pictures.s3.yandex.net/frontend-developer/common/ava.jpg",
  "_id": "e20537ed11237f86bbb20ccb",
  "cohort": "cohort0",
}
```

Метод PATCH обычно используют для обновления сущностей, уже существующих на сервере. Обновление информации о пользователе именно такой случай: пользователь уже есть, нужно просто обновить его данные.

## 4. Добавление новой карточки

Чтобы добавить на сервер новую карточку, отправьте POST-запрос:

```javascript
POST https://mesto.nomoreparties.co/v1/cohortId/cards
```

В заголовках запроса, кроме токена, необходимо отправить Content-Type, а в теле — JSON с двумя свойствами — ```name``` и ```link```. В name должно быть название создаваемой карточки, а в ```link``` — ссылка на картинку. Если запрос прошёл успешно, сервер вернёт ответ с объектом новой карточки:

```javascript
  {
    "likes": [],
    "_id": "5d1f0611d321eb4bdcd707dd",
    "name": "Байкал",
    "link": "https://pictures.s3.yandex.net/frontend-developer/cards-compressed/baikal.jpg",
    "owner": {
      "name": "Jacques Cousteau",
      "about": "Sailor, researcher",
      "avatar": "https://pictures.s3.yandex.net/frontend-developer/ava.jpg",
      "_id": "ef5f7423f7f5e22bef4ad607",
      "cohort": "local"
    },
    "createdAt": "2019-07-05T08:10:57.741Z"
  },
```

## 5. Отображение количества лайков карточки

У каждой карточки есть свойство likes — оно содержит массив пользователей, лайкнувших карточку:

```javascript
{
  "likes": [],
  ...другие данные карточки
}
```

Сделайте так, чтобы на каждой карточке было написано, сколько у неё лайков:

![колличество лайков](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_4.18.50_PM_1592653422.png)

Для этого придётся сверстать дополнительный элемент. [Его дизайн есть в Фигме.](https://www.figma.com/file/PSdQFRHoxXJFs2FH8IXViF/JavaScript-9-sprint?node-id=0%3A1)

## 6. Попап удаления карточки

Удаление чего-то, как правило, безвозвратно. Поэтому перед этим действием стоит спросить пользователя, уверен ли он, что хочет удалить карточку. Для этого сделайте новый попап. Он должен открываться по клику на иконку удаления:

![Попап удаления карточки](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_4.57.34_PM_1592654068.png)

[Дизайн попапа есть в Фигме.](https://www.figma.com/file/PSdQFRHoxXJFs2FH8IXViF/JavaScript-9-sprint?node-id=0%3A1)

## 7. Удаление карточки

Прежде чем браться за работу с API, исправьте элемент карточки. Сделайте так, чтобы иконка удаления была только на созданных вами карточках, так как удалять чужие карточки нельзя.

![Если карточка создана не вами, на ней нет иконки корзины](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_4.18.50_PM_1592653422.png)

После того, как сделаете это, реализуйте функциональность удаления карточки. Карточка должна удаляться, если в попапе удаления карточки пользователь нажал «Да».
Чтобы удалить карточку, отправьте DELETE-запрос:

```javascript
DELETE https://mesto.nomoreparties.co/v1/cohortId/cards/cardId
```

Вместо cardId в URL нужно подставить параметр ```_id``` карточки, которую нужно удалить. ```_id``` каждой карточки есть в её JSON:

```javascript
{
  "likes": [],
  "_id": "5d1f0611d321eb4bdcd707dd", — вот он
  ...другие данные карточки
}
```

В итоге, запрос на удаление этой карточки должен выглядеть так:

```javascript
DELETE https://mesto.nomoreparties.co/v1/cohortId/cards/5d1f0611d321eb4bdcd707dd
```

## 8. Постановка и снятие лайка

Чтобы лайкнуть карточку, отправьте PUT-запрос:

```javascript
PUT https://mesto.nomoreparties.co/v1/cohortId/cards/likes/cardId
```

Чтобы убрать лайк, нужно отправить DELETE-запрос с тем же URL:

```javascript
DELETE https://mesto.nomoreparties.co/v1/cohortId/cards/likes/cardId
```

Вместо ```cardId``` в URL нужно подставить свойство ```_id``` соответствующей карточки.
В ответе придёт обновлённый JSON с карточкой. Массив лайков в нём будет уже обновлён.
При постановке и снятии лайка сердечко должно менять цвет, а счётчик лайков увеличиваться или уменьшаться.
Чтобы изменить количество лайков, нужно прибавить или отнять единицу от актуального количества. Рекомендуем брать это количество из ответа сервера, а не из вёрстки. Иначе возникнут ошибки, когда в одно и то же время два пользователя лайкнут одну карточку.

## 9. Обновление аватара пользователя

Чтобы сменить аватар, отправьте такой PATCH-запрос:

```javascript
PATCH https://mesto.nomoreparties.co/v1/cohortId/users/me/avatar
```

В теле запроса передайте JSON с единственным свойством — ```avatar```. Это свойство должно хранить ссылку на новый аватар. Если отправить не ссылку, сервер вернёт ошибку.
При наведении указателя мыши на аватар, на нём должна появляться иконка редактирования:

![иконка редактирования профиля](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_5.22.48_PM_1592654397.png)

А при клике, открываться форма. Эту форму нужно сделать. В ней должно быть одно поле — ссылка на новый аватар:

![форма редактирования аватара профиля](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_5.46.36_PM_1592654421.png)

Иконка редактирования аватара и форма загрузки [есть в Фигме.](https://www.figma.com/file/PSdQFRHoxXJFs2FH8IXViF/JavaScript-9-sprint?node-id=0%3A1)

## 10. Улучшенный UX всех форм

Поработайте над UX. При редактировании профиля уведомите пользователя о процессе загрузки, поменяв текст кнопки на: «Сохранение...», пока данные загружаются:

![процесс загрузки в форме](https://pictures.s3.yandex.net/resources/Screen_Shot_2020-06-18_at_6.03.28_PM_1592654465.png)

Сделайте то же самое для формы добавления новой карточки и обновления аватара.

### Требования к коду

Для работы с API создайте класс ```Api```. Все запросы должны быть методами этого класса:

```javascript
class Api {
  constructor(options) {
    // тело конструктора
  }

  getInitialCards() {
    // ...
  }

  // другие методы работы с API
}

const api = new Api({
  baseUrl: 'https://mesto.nomoreparties.co/v1/cohort-42',
  headers: {
    authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6',
    'Content-Type': 'application/json'
  }
});
```

### Общие комментарии

**1. Не забывайте проверять, всё ли в порядке с ответом.** Можно использовать ```res.ok``` или ```res.status```:

```javascript
getInitialCards() {
  return fetch('https://mesto.nomoreparties.co/v1/cohort-42/cards', {
    headers: {
      authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6'
    }
  })
    .then(res => {
      if (res.ok) {
        return res.json();
      }
    });
}
```

**2. Учитывайте случай, когда сервер вернул ошибку.**

```javascript
getInitialCards() {
  return fetch('https://mesto.nomoreparties.co/v1/cohort-42/cards', {
    headers: {
      authorization: 'c56e30dc-2883-4270-a59e-b2f7bae969c6'
    }
  })
    .then(res => {
      if (res.ok) {
        return res.json();
      }

      // если ошибка, отклоняем промис
      return Promise.reject(`Ошибка: ${res.status}`);
    });
}
```

**3. Обрабатывайте ошибки, попадающие в catch.** Если запрос не ушёл на сервер, или тот не ответил, сработает блок ```catch```. Обрабатывайте ошибку внутри этого блока. Если нет времени писать сложную логику, хотя бы просто выведите ошибку в консоль.

```javascript
api.getInitialCards()
  .then((result) => {
    // обрабатываем результат
  })
  .catch((err) => {
    console.log(err); // выведем ошибку в консоль
  });
  ```

**4. Пользуйтесь вкладкой Network для просмотра запросов.** При отправке запросов держите вкладку Network открытой. Отфильтруйте в ней XHR запросы. Это позволит оперативно следить, что приходит в ответе от сервера.

### Если проблемы с «Фигмой»

У «Фигмы» есть ограничение на количество одновременных посетителей. Может оказаться, что в макет зашло слишком много студентов, и «Фигма» вас не пустит. Чтобы этого избежать, скачайте копию макета к себе. Легче всего это сделать из [приложения Figma для компьютера](https://www.figma.com/downloads/). После авторизации вы сможете скачать копию проекта с расширением ```.fig```.

![Сохранение проекта на компьютер](https://pictures.s3.yandex.net/resources/Untitled_1592654537.png)

Импортировать файл обратно в «Фигму» можно нажав иконку ”import“ в правом верхнем углу.

![Импорт файла в «Фигму»](https://pictures.s3.yandex.net/resources/import_1592654673.png)

Файл загрузится на вашу личную доску. Комментарии пропадут, но всё необходимое для работы над макетом всегда будет под рукой.

### Чеклист

Не забудьте проверить себя по чеклисту: [https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-9/index.html](https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-9/index.html)
</details>

---
---
---


# Проектная работа № 8
## Mesto
### Задание
<details>
<summary>Подробнее ...</summary>
# Проектная работа 8
В проектной работе этого спринта вы продолжите заниматься рефакторингом. Создадите ещё несколько классов и настроите связи между ними. В завершении проектной работы нужно будет настроить сборку проекта Вебпаком.
## Создайте класс ```Section```
Создайте класс ```Section```, который отвечает за отрисовку элементов на странице. Этот класс:
- Первым параметром конструктора принимает объект с двумя свойствами: ```items``` и ```renderer```. Свойство ```items``` — это массив данных, которые нужно добавить на страницу при инициализации класса. Свойство ```renderer``` — это функция, которая отвечает за создание и отрисовку данных на странице.
- Второй параметр конструктора — селектор контейнера, в который нужно добавлять созданные элементы.
Содержит публичный метод, который отвечает за отрисовку всех элементов. Отрисовка каждого отдельного элемента должна осуществляться функцией ```renderer```.
- Содержит публичный метод ```addItem```, который принимает DOM-элемент и добавляет его в контейнер.
У класса ```Section``` нет своей разметки. Он получает разметку через функцию-колбэк и вставляет её в контейнер.
## Создайте класс ```Popup```
Создайте класс Popup, который отвечает за открытие и закрытие попапа. Этот класс:
- Принимает в конструктор единственный параметр — селектор попапа.
- Содержит публичные методы ```open``` и ```close```, которые отвечают за открытие и закрытие попапа.
- Содержит приватный метод ```_handleEscClose```, который содержит логику закрытия попапа клавишей Esc.
- Содержит публичный метод ```setEventListeners```, который добавляет слушатель клика иконке закрытия попапа.
## Создайте класс PopupWithImage
Создайте класс ```PopupWithImage```, который наследует от ```Popup```. Этот класс должен перезаписывать родительский метод ```open```. В методе ```open``` класса ```PopupWithImage``` нужно вставлять в попап картинку и атрибут ```src``` изображения и подпись к картинке.
## Создайте класс PopupWithForm
Создайте класс ```PopupWithForm```, который наследует от ```Popup```. Этот класс:
- Кроме селектора попапа принимает в конструктор колбэк сабмита формы.
- Содержит приватный метод ```_getInputValues```, который собирает данные всех полей формы.
- Перезаписывает родительский метод ```setEventListeners```. Метод ```setEventListeners``` класса ```PopupWithForm``` должен не только добавлять обработчик клика иконке закрытия, но и добавлять обработчик сабмита формы.
- Перезаписывает родительский метод ```close```, так как при закрытии попапа форма должна ещё и сбрасываться.
Для каждого попапа создавайте свой экземпляр класса ```PopupWithForm```.
## Создайте класс ```UserInfo```
Класс ```UserInfo``` отвечает за управление отображением информации о пользователе на странице. Этот класс:
- Принимает в конструктор объект с селекторами двух элементов: элемента имени пользователя и элемента информации о себе.
- Содержит публичный метод ```getUserInfo```, который возвращает объект с данными пользователя. Этот метод пригодится когда данные пользователя нужно будет подставить в форму при открытии.
- Содержит публичный метод ```setUserInfo```, который принимает новые данные пользователя и добавляет их на страницу.
## Преобразуйте класс ```Card```
Свяжите класс ```Card``` c попапом. Сделайте так, чтобы Card принимал в конструктор функцию ```handleCardClick```. Эта функция должна открывать попап с картинкой при клике на карточку.
## Создайте файл ```.gitignore```
Следующим заданием будет инициализация npm и настройка Webpack. Это значит, что в проекте появятся папки ```node_modules``` и ```dist```. Эти папки не принято добавлять в git-репозиторий, так как любой разработчик может сгенерировать их у себя на компьютере. Для этого достаточно иметь ```package.json```.
Чтобы ```node_modules``` и ```dist``` не попадали в репозиторий, нужно научить git их игнорировать. Для этого в корне проекта создайте файл ```.gitignore``` и добавьте в него две строки:

```javascript
node_modules
dist
```

Сохраните файл. Теперь git не будет обращать внимание на эти папки.

Примечание: перед тем, как отправить проект на код-ревью, добавьте ```node_modules``` в файл ```.gitignore```. Иначе проект не загрузится или ревьюер отклонит его от проверки.
## Настройте сборку Вебпаком
1. Инициализируйте **npm** в проекте.
2. Установите ```webpack```, ```webpack-cli``` и ```webpack-dev-server```.
3. Настройте две сборки: ```build``` и ```dev```. Создайте соответствующие скрипты в ```package.json```. Скрипт ```build``` должен пересоздавать папку ```dist``` с собранным проектом. Скрипт ```dev``` запускать проект на локальном сервере.
4. Настройте минификацию и транспиляцию JS бабелем. Из ```index.html``` уберите теги ```script``` с подключением скриптов. Вебпак должен собирать весь JavaScript в один файл и автоматически добавлять в HTML тег script со ссылкой на него.
5. Настройте обработку CSS: в HTML больше не должно быть тега ```link``` со ссылкой на CSS-файл. За обработку и подключение CSS должен отвечать Webpack.
6. Настройте минификацию CSS и автоматическое добавление вендорных префиксов.
7. Настройте обработку изображений и шрифтов.
8. Настройте обработку HTML: если в HTML есть ссылки на локальные картинки, при сборке всё должно работать.

HTML, CSS и JS-файлы должны быть в папке ```src```. Итоговая структура проекта должна быть такой:

![Итоговая структура проекта](https://pictures.s3.yandex.net/resources/iMac_-_3_1591519690.png)

Требования к коду
- Добавьте в проект классы ```Section```, ```Popup```, ```PopupWithForm```, ```PopupWithImage``` и ```UserInfo```. Каждый из них выполняет строго одну задачу. Всё, что относится к решению этой задачи, находится внутри класса.
- Если классы нужно связать друг с другом, делайте это передаваемой в конструктор функцией-колбэком.
- Все классы должны быть вынесены в отдельные файлы.
- В файле ```index.js``` должно остаться только создание классов и добавление некоторых обработчиков.

## Чеклист
Не забудьте проверить себя по чеклисту: [https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-8/index.html](https://code.s3.yandex.net/web-developer/checklists/new-program/checklist-8/index.html)
</details>

---
---
---
